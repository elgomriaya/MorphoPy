{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "084603a0-b74c-4f90-afd4-c7949f2a3e90",
   "metadata": {},
   "outputs": [
    {
     "ename": "IndentationError",
     "evalue": "unindent does not match any outer indentation level (<string>, line 11)",
     "output_type": "error",
     "traceback": [
      "\u001b[1;36m  File \u001b[1;32m<string>:11\u001b[1;36m\u001b[0m\n\u001b[1;33m    def appliquer_cisaillement(self, shx, shy):\u001b[0m\n\u001b[1;37m                                               ^\u001b[0m\n\u001b[1;31mIndentationError\u001b[0m\u001b[1;31m:\u001b[0m unindent does not match any outer indentation level\n"
     ]
    }
   ],
   "source": [
    " return\n",
    "        top = Toplevel(self.window)\n",
    "        top.title(\"Cisaillement\")\n",
    "        top.geometry(\"400x400\")\n",
    "        top.configure(bg=COL_CARD)\n",
    "        Label(top, text=\"Cisaillement (Shear)\", font=(\"Helvetica\", 14, \"bold\"), bg=COL_CARD, fg=COL_TEXT_MAIN).pack(pady=20)\n",
    "        scale_x = Scale(top, from_=-1.0, to=1.0, resolution=0.1, orient=HORIZONTAL, bg=COL_CARD, length=300, label=\"X\"); scale_x.set(0.0); scale_x.pack(pady=10)\n",
    "        scale_y = Scale(top, from_=-1.0, to=1.0, resolution=0.1, orient=HORIZONTAL, bg=COL_CARD, length=300, label=\"Y\"); scale_y.set(0.0); scale_y.pack(pady=10)\n",
    "        ttk.Button(top, text=\"Appliquer\", style=\"Accent.TButton\", command=lambda: self.appliquer_cisaillement(scale_x.get(), scale_y.get())).pack(pady=20)\n",
    "\n",
    "    def appliquer_cisaillement(self, shx, shy):\n",
    "        target = self.get_target_image()\n",
    "        if target:\n",
    "            if target.mode == 'RGB': img_np = cv2.cvtColor(np.array(target), cv2.COLOR_RGB2BGR)\n",
    "            else: img_np = cv2.cvtColor(np.array(target.convert(\"RGB\")), cv2.COLOR_RGB2BGR)\n",
    "            h, w = img_np.shape[:2]\n",
    "            M = np.float32([[1, shx, 0], [shy, 1, 0]])\n",
    "            # Bounding box recalculation\n",
    "            pts = np.float32([[0,0], [w,0], [0,h], [w,h]])\n",
    "            pts_homo = np.hstack([pts, np.ones((4, 1), dtype=np.float32)])\n",
    "            new_pts = M.dot(pts_homo.T).T\n",
    "            x_min = new_pts[:, 0].min(); x_max = new_pts[:, 0].max()\n",
    "            y_min = new_pts[:, 1].min(); y_max = new_pts[:, 1].max()\n",
    "            new_w = int(x_max - x_min); new_h = int(y_max - y_min)\n",
    "            M[0, 2] = -x_min; M[1, 2] = -y_min\n",
    "            img_sheared = cv2.warpAffine(img_np, M, (new_w, new_h), borderValue=(255, 255, 255))\n",
    "            res_pil = Image.fromarray(cv2.cvtColor(img_sheared, cv2.COLOR_BGR2RGB))\n",
    "            self.finaliser_traitement(np.array(res_pil), f\"Shear X={shx}, Y={shy}\")\n",
    "\n",
    "    def ouvrir_fenetre_symetrie(self):\n",
    "        target_img = self.get_target_image()\n",
    "        if target_img is None: return\n",
    "        top = Toplevel(self.window)\n",
    "        top.title(\"Symétrie\")\n",
    "        top.geometry(\"400x250\")\n",
    "        top.configure(bg=COL_CARD)\n",
    "        ttk.Button(top, text=\"Miroir Horizontal (↔)\", style=\"Accent.TButton\", command=lambda: self.appliquer_symetrie(1)).pack(fill=X, padx=40, pady=20)\n",
    "        ttk.Button(top, text=\"Miroir Vertical (↕)\", style=\"Filter.TButton\", command=lambda: self.appliquer_symetrie(0)).pack(fill=X, padx=40, pady=10)\n",
    "\n",
    "    def appliquer_symetrie(self, flip_code):\n",
    "        target = self.get_target_image()\n",
    "        if target:\n",
    "            if target.mode == 'RGB': img_np = cv2.cvtColor(np.array(target), cv2.COLOR_RGB2BGR)\n",
    "            else: img_np = cv2.cvtColor(np.array(target.convert(\"RGB\")), cv2.COLOR_RGB2BGR)\n",
    "            img_flipped = cv2.flip(img_np, flip_code)\n",
    "            res_pil = Image.fromarray(cv2.cvtColor(img_flipped, cv2.COLOR_BGR2RGB))\n",
    "            self.finaliser_traitement(np.array(res_pil), \"Symétrie\")\n",
    "\n",
    "    def ouvrir_fenetre_translation(self):\n",
    "        target_img = self.get_target_image()\n",
    "        if target_img is None: return\n",
    "        top = Toplevel(self.window)\n",
    "        top.title(\"Translation\")\n",
    "        top.geometry(\"400x350\")\n",
    "        top.configure(bg=COL_CARD)\n",
    "        scale_x = Scale(top, from_=-200, to=200, orient=HORIZONTAL, label=\"X\", bg=COL_CARD, length=300); scale_x.set(0); scale_x.pack(pady=10)\n",
    "        scale_y = Scale(top, from_=-200, to=200, orient=HORIZONTAL, label=\"Y\", bg=COL_CARD, length=300); scale_y.set(0); scale_y.pack(pady=10)\n",
    "        ttk.Button(top, text=\"Appliquer\", style=\"Accent.TButton\", command=lambda: self.appliquer_similitude_logique(0, 1.0, scale_x.get(), scale_y.get(), \"Translation\")).pack(pady=20)\n",
    "\n",
    "    def ouvrir_fenetre_rotation(self):\n",
    "        target_img = self.get_target_image()\n",
    "        if target_img is None: return\n",
    "        top = Toplevel(self.window)\n",
    "        top.title(\"Rotation\")\n",
    "        top.geometry(\"400x350\")\n",
    "        top.configure(bg=COL_CARD)\n",
    "        scale_angle = Scale(top, from_=-180, to=180, orient=HORIZONTAL, label=\"Angle\", bg=COL_CARD, length=300); scale_angle.set(0); scale_angle.pack(pady=10)\n",
    "        ttk.Button(top, text=\"Appliquer\", style=\"Accent.TButton\", command=lambda: self.appliquer_similitude_logique(scale_angle.get(), 1.0, 0, 0, \"Rotation\")).pack(pady=20)\n",
    "\n",
    "    # --- MORPHOLOGIE & FILTRES ---\n",
    "    def traitement_gris(self):\n",
    "        if self.image_originale_pil:\n",
    "            img = np.array(self.image_originale_pil.convert(\"RGB\"))\n",
    "            r, g, b = img[:,:,0], img[:,:,1], img[:,:,2]\n",
    "            gray = 0.2989 * r + 0.5870 * g + 0.1140 * b\n",
    "            self.finaliser_traitement(gray.astype(np.uint8), \"Niveau de Gris\")\n",
    "\n",
    "    def traitement_binaire(self):\n",
    "        targ = self.get_target_image()\n",
    "        if targ:\n",
    "            arr = np.array(targ.convert(\"L\"))\n",
    "            bin_arr = np.where(arr > 128, 255, 0).astype(np.uint8)\n",
    "            self.finaliser_traitement(bin_arr, \"Binarisation\")\n",
    "\n",
    "    def morph_base(self, operation):\n",
    "        target = self.get_target_image()\n",
    "        if target:\n",
    "            if target.mode != 'L': self.traitement_gris(); target = self.image_resultat_pil\n",
    "            arr = np.array(target)\n",
    "            es_np = np.array(self.es, dtype=np.uint8)\n",
    "            kernel = np.where(es_np == 1, 1, 0).astype(np.uint8) \n",
    "            if operation == 'erode': res = cv2.erode(arr, kernel, iterations=1)\n",
    "            else: res = cv2.dilate(arr, kernel, iterations=1)\n",
    "            self.finaliser_traitement(res, operation.capitalize())\n",
    "\n",
    "    def traitement_erosion(self): self.morph_base('erode')\n",
    "    def traitement_dilatation(self): self.morph_base('dilate')\n",
    "    def traitement_ouverture(self): self.traitement_erosion(); self.traitement_dilatation(); self.lbl_info.config(text=\"Ouverture\")\n",
    "    def traitement_fermeture(self): self.traitement_dilatation(); self.traitement_erosion(); self.lbl_info.config(text=\"Fermeture\")\n",
    "    def traitement_erosion_BN(self): self.traitement_erosion()\n",
    "    def traitement_dilatation_BN(self): self.traitement_dilatation()\n",
    "\n",
    "    def appliquer_kernel(self, k, nom):\n",
    "        target = self.get_target_image()\n",
    "        if target:\n",
    "            src = np.array(target.convert(\"L\")) \n",
    "            res = cv2.filter2D(src, -1, k)\n",
    "            self.finaliser_traitement(res, nom)\n",
    "\n",
    "    def ouvrir_fenetre_moyenne(self): k = np.ones((3,3), np.float32)/9; self.appliquer_kernel(k, \"Moyenne 3x3\")\n",
    "    def ouvrir_fenetre_GAUSSIEN(self): k = np.array([[1,2,1],[2,4,2],[1,2,1]], dtype=np.float32) / 16; self.appliquer_kernel(k, \"Gaussien 3x3\")\n",
    "    def ouvrir_fenetre_MEDIAN(self):\n",
    "        target = self.get_target_image()\n",
    "        if target:\n",
    "            res = cv2.medianBlur(np.array(target.convert(\"L\")), 5)\n",
    "            self.finaliser_traitement(res, \"Médian 5x5\")\n",
    "    def ouvrir_fenetre_DESPECKLE(self):\n",
    "        target = self.get_target_image()\n",
    "        if target:\n",
    "            res = cv2.fastNlMeansDenoising(np.array(target.convert(\"L\")), None, 30, 7, 21)\n",
    "            self.finaliser_traitement(res, \"Déparasitage\")\n",
    "    def ouvrir_fenetre_SOBEL(self): k = np.array([[-1,0,1],[-2,0,2],[-1,0,1]], dtype=np.float32); self.appliquer_kernel(k, \"Sobel Horizontal\")\n",
    "    def ouvrir_fenetre_PREWITT(self): k = np.array([[-1,0,1],[-1,0,1],[-1,0,1]], dtype=np.float32); self.appliquer_kernel(k, \"Prewitt Horizontal\")\n",
    "    def ouvrir_fenetre_LAPLACIEN(self): k = np.array([[0,-1,0],[-1,4,-1],[0,-1,0]], dtype=np.float32); self.appliquer_kernel(k, \"Laplacien\")\n",
    "    def ouvrir_fenetre_KIRSCH(self): k = np.array([[-3,-3,5],[-3,0,5],[-3,-3,5]], dtype=np.float32); self.appliquer_kernel(k, \"Kirsch Est\")\n",
    "    \n",
    "    def ouvrir_fenetre_es(self):\n",
    "        fenetre_es = Toplevel(self.window)\n",
    "        fenetre_es.title(\"Matrice Structurante\")\n",
    "        fenetre_es.geometry(\"400x500\") \n",
    "        fenetre_es.config(bg=COL_BG_MAIN)\n",
    "        var_taille = IntVar(value=self.es_taille)\n",
    "        frame_grid = Frame(fenetre_es, bg=COL_BG_MAIN)\n",
    "        self.entries_es = [] \n",
    "        \n",
    "        def generer_grille():\n",
    "            for widget in frame_grid.winfo_children(): widget.destroy()\n",
    "            self.entries_es = []\n",
    "            taille = var_taille.get()\n",
    "            for i in range(taille):\n",
    "                row_entries = []\n",
    "                for j in range(taille):\n",
    "                    e = Entry(frame_grid, width=4, justify=\"center\", font=(\"Arial\", 12), relief=\"flat\", highlightthickness=1, highlightbackground=COL_BORDER) \n",
    "                    e.grid(row=i, column=j, padx=5, pady=5, ipady=8)\n",
    "                    val = self.es[i][j] if i < len(self.es) and j < len(self.es[0]) else 1\n",
    "                    e.insert(0, str(val))\n",
    "                    row_entries.append(e)\n",
    "                self.entries_es.append(row_entries)\n",
    "            frame_grid.pack(pady=20)\n",
    "\n",
    "        def valider_matrice():\n",
    "            try:\n",
    "                nouvelle_es = []\n",
    "                taille = var_taille.get()\n",
    "                for i in range(taille):\n",
    "                    ligne = []\n",
    "                    for j in range(taille):\n",
    "                        val = float(self.entries_es[i][j].get() or 0)\n",
    "                        ligne.append(val)\n",
    "                    nouvelle_es.append(ligne)\n",
    "                self.es = nouvelle_es\n",
    "                self.es_taille = taille\n",
    "                messagebox.showinfo(\"Succès\", \"Matrice enregistrée\", parent=fenetre_es)\n",
    "                fenetre_es.destroy() \n",
    "            except ValueError:\n",
    "                messagebox.showerror(\"Erreur\", \"Valeurs incorrectes\", parent=fenetre_es)\n",
    "\n",
    "        Label(fenetre_es, text=\"Configuration Noyau\", bg=COL_BG_MAIN, font=(\"Helvetica\", 12, \"bold\")).pack(pady=15)\n",
    "        fr = Frame(fenetre_es, bg=COL_BG_MAIN)\n",
    "        fr.pack()\n",
    "        Radiobutton(fr, text=\"3 x 3\", variable=var_taille, value=3, command=generer_grille, bg=COL_BG_MAIN).pack(side=LEFT, padx=10)\n",
    "        Radiobutton(fr, text=\"5 x 5\", variable=var_taille, value=5, command=generer_grille, bg=COL_BG_MAIN).pack(side=LEFT, padx=10)\n",
    "        generer_grille()\n",
    "        ttk.Button(fenetre_es, text=\"Valider\", style=\"Accent.TButton\", command=valider_matrice).pack(pady=10)\n",
    "\n",
    "if __name__ == '__main__':\n",
    "    app = MyApp()\n",
    "    app.window.mainloop()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b4165155-621d-4ce3-bcd9-a30800930c6f",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.13.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
